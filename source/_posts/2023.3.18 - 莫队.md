---
title: 莫队 | 学习笔记
date: 2023-03-07 21:39:16
categories: 算法
tags: 算法
author: Shawn
cover: https://img2.baidu.com/it/u=1834542261,81809892&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500
---
# 莫队算法
> 莫队算法本质是暴力思想\
离线算法

## 模板题
[P1972 [SDOI2009] HH的项链](https://www.luogu.com.cn/problem/P1972)

* 洛谷卡莫队，AcWing可过qwq

[AcWing 2492.HH的项链](https://www.acwing.com/problem/content/2494/)

### 本质
分析题意易知，本题要找一段序列出现的不同数字

### 暴力思路
时间复杂度$O(snm)$

每次出现一个数字就及记录在`cnt`数组中，然后寻找`cnt`中的非零数字的量，即为结果

### 暴力优化
时间复杂度$O(nm)$

在每次记录`cnt`的时候，当`cnt[i] = 1`时不计入新的数字，只在`cnt[i] = 0`时递增答案

### 双指针优化
时间复杂度$O(nm)$（最坏情况）
用`i`指向末尾，`j`指向开头，每次利用前一个区间来更改下一个区间，维护`cnt`数组

### 莫队做法
> 莫队算法用于优化暴力算法\
调整区间查询的顺序，实现算法的优化

时间复杂度$O(m\sqrt n)$

#### 方法分析
+ 右指针：递增
+ 左指针：
    1. 按照**分块**的编号排序
    2. 右端点的下标

#### 时间复杂度分析：
+ 右指针：则共有$\sqrt n$块，每一块内部走$n$次，一共走$n\sqrt n$次
+ 左指针：
    1. 块内移动：$\sqrt n$， 总$m\sqrt n$
    2. 块间移动：最坏$2\sqrt n$，总$2n$
对以上两个部分取最大值，算法的总时间复杂度为$O(m\sqrt n)$

#### 玄学优化
**分两种情况排序**

1. 奇数块按照右端点从小到大排
2. 偶数块按照右端点从大到小排
* 可以反过来

优化思路：
+ 原方法：

第一段右端点从左到右滚动，然后滚回去，再从左向右滚动第二段

+ 优化后方法：

第一段右端点从左到右滚动，直接从右向左滚动第二段

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cstdio>

using namespace std;

const int N = 50010, M = 200010, S = 1000010;

int n, m, len;
int w[N], ans[M];//w存每个位置的数，ans存答案
struct Query//存储所有询问
{
    int id, l, r;//id代表询问的数，l, r分别代表左右端点
}q[M];
int cnt[S];//cnt存储每个数出现的次数


int get(int x)//求每一个位置所处块的编号
{
    return x / len;
}

bool cmp(const Query& a, const Query& b)
{
    int i = get(a.l), j = get(b.l);//获取所在块的编号
    if(i != j)
        return i < j;//不同块则判定块的大小
    //本题目未使用奇偶分别排序
    return a.r < b.r; //块内按照从小到大排序
}


void add(int x, int& res)
{
    if(!cnt[x])
        res ++;
    cnt[x] ++;
}

void del(int x, int& res)
{
    cnt[x] --;
    if(!cnt[x])
        res --;
}

int main()
{
    // ios::sync_with_stdio(false);
    // cin.tie(0);
    // cout.tie(0);
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++)
        scanf("%d", &w[i]);

    scanf("%d", &m);
    len = max(1, (int)sqrt((double)n * n / m));//计算最大长度
    for(int i = 1; i <= m; i ++)
    {
        int l, r;
        scanf("%d%d", &l, &r);
        q[i] = {i, l, r};
    }

    sort(q + 1, q + m + 1, cmp);

    for(int k = 1, i = 0, j = 1, res = 0; k <= m; k ++)//i在j的后面一位，表示区间为空
    {
        int id = q[k].id, l = q[k].l, r = q[k].r;
        while(i < r)//右节点比r小，则右移右节点(加入数据)
            add(w[++ i], res);
        while(i > r)//右节点比r大，则左移右节点(删除数据)
            del(w[i --], res);
        while(j < l)//左节点比l小，则右移左节点(删除数据)
            del(w[j ++], res);
        while(j > l)//左节点比l大，则左移左节点(加入数据)
            add(w[-- j], res);
        ans[id] = res;
    }

    for(int i = 1; i <= m; i ++)
        printf("%d\n", ans[i]);
    
    return 0;
}
```



